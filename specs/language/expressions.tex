\Ch{Expressions}{Expr}

\p This chapter defines the formulations of expressions and the behavior of
operators when they are not overloaded. Only member operators may be
overloaded\footnote{This will change in the future, but this document assumes
current behavior.}. Operator overloading does not alter the rules for operators
defined by this standard.

\p An expression may also be an \textit{unevaluated operand} when it appears in
some contexts. An \textit{unevaluated operand} is a expression which is not
evaluated in the program\footnote{The operand to \texttt{sizeof(...)} is a good
example of an \textit{unevaluated operand}. In the code \texttt{sizeof(Foo())},
the call to \texttt{Foo()} is never evaluated in the program.}.

\p Whenever a \textit{glvalue} appears in an expression that expects a
\textit{prvalue}, a standard conversion sequence is applied based on the rules
in \ref{Conv}.

\Sec{Usual Arithmetic Conversions}{Expr.conv}
\p Binary operators for arithmetic and enumeration type require that both
operands are of a common type. When the types do not match the \textit{usual
arithmetic conversions} are applied to yield a common type. When \textit{usual
arithmetic conversions} are applied to vector operands they behave as
component-wise conversions (\ref{Conv.cwise}). The \textit{usual arithmetic
conversions} are:

\begin{itemize}
  \item If either operand is of scoped enumeration type no conversion is
  performed, and the expression is ill-formed if the types do not match.
  \item If either operand is a \texttt{vector<T,X>}, vector extension is
  performed with the following rules:
  \begin{itemize}
    \item If both vectors are of the same length, no extension is required.
    \item If one operand is a vector and the other operand is a scalar, the
    scalar is extended to a vector via a Splat conversion (\ref{Conv.vsplat}).
    \item Otherwise, if both operands are vectors of different lengths, the
    expression is ill-formed.
  \end{itemize}
  \item If either operand is of type \texttt{double} or \texttt{vector<double,
  X>}, the other operator shall be converted to match.
  \item Otherwise, if either operand is of type \texttt{float} or \texttt{vector<float,
  X>}, the other operand shall be converted to match.
  \item Otherwise, if either operand is of type \texttt{half} or \texttt{vector<half, X>},
  the other operand shall be converted to match.
  \item Otherwise, integer promotions are performed on each scalar or vector
  operand following the appropriate scalar or component-wise conversion
  (\ref{Conv}).
  \begin{itemize}
    \item If both operands are scalar or vector elements of signed or unsigned
    types, the operand of lesser integer conversion rank shall be converted to
    the type of the operand with greater rank.
    \item Otherwise, if both the operand of unsigned scalar or vector element
    type is of greater rank than the operand of signed scalar or vector element
    type, the signed operand is converted to the type of the unsigned operand.
    \item Otherwise, if the operand of signed scalar or vector element type is
    able to represent all values of the operand of unsigned scalar or vector
    element type, the unsigned operand is converted to the type of the signed
    operand.
    \item Otherwise, both operands are converted to a scalar or vector type of
    the unsigned integer type corresponding to the type of the operand with
    signed integer scalar or vector element type.
  \end{itemize}
\end{itemize}

\Sec{Primary Expressions}{Expr.Primary}

\begin{grammar}
  \define{primary-expression}\br
  literal\br
  \keyword{this}\br
  \terminal{(} expression \terminal{)}\br
  id-expression\br
\end{grammar}

\Sub{Literals}{Expr.Primary.Literal}

\p The type of a \textit{literal} is determined based on the grammar forms
specified in \ref{Lex.Literal.Kinds}.

\Sub{This}{Expr.Primary.This}

\p The keyword \keyword{this} names a reference to the implicit object of
non-static member functions. The \keyword{this} parameter is always a
\textit{prvalue} of non-\textit{cv-qualified}type.
\footnote{
  \href{https://github.com/microsoft/hlsl-specs/blob/main/proposals/0007-const-instance-methods.md}
  {HLSL Specs Proposal 0007} proposes adopting C++-like syntax and semantics for
  \textit{cv-qualified} \keyword{this} references.}
  
\p A \keyword{this} expression shall not appear outside the declaration of a
non-static member function.

\Sub{Parenthesis}{Expr.Primary.Paren}

\p An expression (\textit{E}) enclosed in parenthesis has the same type, result
and value category as \textit{E} without the enclosing parenthesis. A
parenthesized expression may be used in the same contexts with the same meaning
as the same non-parenthesized expression.

\Sub{Names}{Expr.Primary.ID}

\begin{note}
  The grammar and behaviors of this section are almost identical to C/C++ with
  some subtractions (notably lambdas and destructors).
\end{note}

\begin{grammar}
  \define{id-expression}\br
  unqualified-id\br
  qualified-id
\end{grammar}

\SubSub{Unqualified Identifiers}{Expr.Primary.ID.Unqual}

\begin{grammar}
  \define{unqualified-id}\br
  identifier\br
  operator-function-id\br
  conversion-function-id\br
  template-id\br
\end{grammar}

\SubSub{Qualified Identifiers}{Expr.Primary.ID.Qual}

\begin{grammar}
  \define{qualified-id}\br
  nested-name-specifier \opt{\keyword{template}} unqualified-id\br
  \define{nested-name-specifier}\br
  \terminal{::}\br
  type-name \terminal{::}\br
  namespace-name \terminal{::}\br
  nested-name-specifier identifier \terminal{::}\br
  nested-name-specifier \opt{\keyword{template}} simple-template-id \terminal{::}
\end{grammar}

\Sec{Postfix Expressions}{Expr.Post}

\begin{grammar}
  \define{postfix-expression}\br
  primary-expression\br
  postfix-expression [ expression ]\br
  postfix-expression [ braced-init-list ]\br
  postfix-expression \terminal{(} \opt{expression-list} \terminal{)}\br
  simple-type-specifier \terminal{(} \opt{expression-list} \terminal{)}\br
  typename-specifier \terminal{(} \opt{expression} \terminal{)}\br
  simple-type-specifier braced-init-list\br
  typename-specifier braced-init-list\br
  postfix-expression \terminal{.} \opt{\terminal{template}} id-expression\br
  postfix-expression \terminal{->} \opt{\terminal{template}} id-expression\br
  postfix-expression \terminal{++}\br
  postfix-expression \terminal{--}
\end{grammar}

\Sec{Subscript}{Expr.Post.Subscript}

\p A \textit{postfix-expression} followed by an expression in square brackets
(\texttt{[ ]}) is a subscript expression. In an array subscript expression of
the form \texttt{E1[E2]}, \texttt{E1} must either be a variable of array of
\texttt{T[]}, or an object of type \texttt{T} where \texttt{T} provides an
overloaded implementation of \texttt{operator[]} (\ref{Overload}).\footnote{HLSL
does not support the base address of a subscript operator being the expression
inside the braces, which is valid in C and C++.}
